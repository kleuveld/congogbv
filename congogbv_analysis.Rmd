---
title: Data analysis for Sexual violence, conflict, and female empowerment
author: Koen Leuveld
output: pdf_document
#bibliography: literature/references.bib


#more info:
#https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf
---

# Intro

This rmarkdown file analyses data, and prepares input tables for the paper. These
input tables do not contain any formatting, just the coefficients. The paper itself
will do the formatting. This means that the input tables can go on GitHub, even if 
the raw data itself can't, and GitHub can thus build the paper.

# Load packages and data

For now, I will just use the Stata data as prepared by `congogbv_dataprep.do`:

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

library(tidyverse)
library(haven)
library(here)


cleandata <- read_dta(here("data/clean/analysis.dta"))
col_labels <- map_chr(cleandata,function(x) coalesce(attributes(x)$label,""))


sample <- 
  cleandata %>%
  filter(!is.na(ball5)) %>%
  mutate(Treatment = ifelse(ball5," Treatment","  Control"))

tibble(Variable = colnames(cleandata),
       label = col_labels) %>%
write_csv(here("tables/cleandata_collabels.csv"))

# to extract:
# col_labels <-
#   read_csv(here("tables/cleandata_collabels.csv")) %>%
#   pull(label) %>%
#   set_names(read_csv(here("tables/cleandata_collabels.csv")) %>% pull(Variable))



dhs <- read_dta(here("data/clean/dhs.dta"))

```


# Tables

## Table 1

Then I create Table 1. For now it's pivoted compared to the orignal, but that's fine.

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

wgt_mean <- function(data,weights,digits=2){
   num(sum(data * weights)/sum(weights),digits=digits)
}

dhs_national <-
  dhs %>% 
  summarize(across(.cols = c(agewife,tinroof:eduwife_sec),
                         .fns  = ~wgt_mean(.x,wgt))) %>%
  mutate(label = "dhs_national")

dhs_skivu <-
  dhs %>% 
  filter(province == 11) %>%
  summarize(across(.cols = c(agewife,tinroof:eduwife_sec),
                         .fns  = ~wgt_mean(.x,wgt)))%>%
  mutate(label = "dhs_skivu")

sample_full <-
cleandata %>% 
summarize(across(.cols = c(agewife,tinroof,eduwife_prim,eduwife_sec),
                .fns = ~mean(.x, na.rm = TRUE) %>% num(digits = 2)))%>%
  mutate(label = "sample_full")

sample_gendermodule <-
cleandata %>% 
  filter(!is.na(ball5)) %>%
  summarize(across(.cols = c(agewife,tinroof,eduwife_prim,eduwife_sec),
                  .fns = ~mean(.x, na.rm = TRUE) %>% num(digits = 2)))%>%
  mutate(label = "sample_gendermodule")

rbind(dhs_national,dhs_skivu,sample_full,sample_gendermodule) %>%
write_csv(here("tables/table1.csv"))


```


## Table 2

I need to add the labels still:

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

library(janitor)

cleandata %>% 
  tabyl(riskwifestatus,riskhusbandstatus) %>%
  adorn_totals(c("row", "col")) %>%
  write_csv(here("tables/table2.csv"))

```

## Table 3

Payouts

## Table 4

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}



#define function to get summ stats
get_summ_stats <- function(.df, by = NULL, overall = NULL) {
  
  #this expands the data frame to include an "overall" treatment condition
  if (!missing(by)) {

    if (!is.null(overall)) {
      .df <- 
        bind_rows(.df, .df %>% mutate({{ by }} := overall ))
    }

    .df <- 
      .df %>%
      group_by( {{ by }} )
  }

  .df %>%
    summarize(across(everything(),
                       list(
                            #label = ~coalesce(attributes(.x)$label,""),
                            n =  ~sum(!is.na(.x)),
                            nmiss =  ~sum(is.na(.x)),
                            mean = ~mean(.x,na.rm=TRUE),
                            sd = ~sd(.x,na.rm=TRUE),
                            min =  ~min(.x,na.rm=TRUE),
                            max =  ~max(.x,na.rm=TRUE),
                            iqr =  ~IQR(.x,na.rm=TRUE)),
                        .names =  "{.col}-{.fn}"))   %>%
  pivot_longer(cols = - {{ by }} ,
               names_to = c("Variable",".value"),
               names_sep="-") 

}






sample %>%  
  select(Treatment, numballs,victimproplost, victimfamlost, acledviolence10) %>%
  get_summ_stats(by= Treatment, overall = "Overall") %>%
  write_csv(here("tables/summstats.csv"))


#this function returns a string to put in a column of differences
get_diffs <- function(.df,y,x){

  reg <-  lm(y~ x) %>% broom::tidy()

  coeff = round(reg[2,2],2)
  p <- reg[2,5]

  stars = case_when(p < 0.001 ~ "***",
                    p < 0.01 ~ "**",
                    p < 0.05 ~ "*",
                    .default = "" )

  paste0(coeff,stars)
}


sample %>%
  select(numballs,victimproplost, victimfamlost, acledviolence10) %>%
  summarize(across(everything(),
                   .fns = function(x) get_diffs(.,.$x,as.factor(sample$Treatment)))) %>%
  pivot_longer(cols =everything(),
               names_to = "Variable",
               values_to="Difference")  %>%
  write_csv(here("tables/summstats_diffs.csv"))

#to the Rmd


library(flextable)


# flextable orders the variables alphabetically, but I want to preserve the order
# because the variabe order is the same in summstats and difcol, I can just use sequential numbers
# making sure to do the same with the labels 
numvars <- read_csv(here("tables/summstats_diffs.csv")) %>% nrow()
numtreatment <- 3

summstats <- 
  read_csv(here("tables/summstats.csv")) %>%
  left_join(read_csv(here("tables/cleandata_collabels.csv"))) %>%
  mutate(Variable = str_pad(rep(1:numvars,numtreatment),2,pad="0")) 

difcol <- 
  read_csv(here("tables/summstats_diffs.csv")) %>%
  mutate(Variable = str_pad(1:numvars,2,pad="0"))

labels <- summstats %>% pull(label) %>% unique()
names(labels) <- str_pad(1:numvars,2,pad="0")

summstats %>%
  tabulator(rows = "Variable",
            columns = "Treatment",
            datasup_last = difcol,
            `N` = as_paragraph(as_chunk(n,digits=0)),
            `Mean (SD)` =  as_paragraph(as_chunk(fmt_avg_dev(mean, sd, digit1=2,digit2 = 2)))) %>%
  as_flextable() %>%
  labelizor(j = "Variable", labels = labels, part = "all") %>% 
  fix_border_issues() %>%
  autofit()



```

## Table 5: Conflict Exposure by Territory



```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}


create_codebook(cleandata) %>% View()

cleandata %>%
  select(victimproplost,victimfamlost,acledviolence10, territory) %>%
  mutate(Territory = case_when(territory == 1 | territory == 2 ~ " Kabare/Bagira",
                               territory == 3 ~ " Uvira",
                               territory == 4 ~ " Fizi")) %>%
  select(-territory) %>%
  get_summ_stats(by= Territory, overall = "Overall") %>%
  write_csv(here("tables/violence_by_territory.csv"))

# To Paper

read_csv(here("tables/violence_by_territory.csv")) %>%
  tabulator(rows = "Variable",
            columns = "Territory",
            `Mean (SD)` =  as_paragraph(as_chunk(fmt_avg_dev(mean, sd, digit1=2,digit2 = 2)))) %>%
  as_flextable() %>%
  labelizor(j = "Variable", labels = col_labels, part = "all") %>% 
  fix_border_issues() %>%
  autofit()



```


## Table 6

The function (`mean_diff_table()`) to create this table is a bit ugly, but i consists of three sub-functions:

- `get_means()` computes the means of treatment and control for each value of a binary...
- `get_meandiffs()` comutes the differences between the treatment and control for each group using a regression; and,
- `get_diffindiff()` computes the DiD using a regression.

Each function outputs a data frame in long format: these are bound together to one large one, that can be used by `flextable::tabulator()`.

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

library(estimatr)


mean_diff_table <- function(.df,var){

  # this functions gets 4 means: treatment assignment x values of var
  # it returns a long data frame with one row per mean
  get_means <- function(.df, var){
    .df %>%
      mutate( {{ var }} := as.character(as_factor( {{ var }} ))) %>%
      select(numballs,Treatment,{{ var }})   %>%
      group_by(Treatment, {{ var }} ) %>%
      summarize(across(numballs, ~mean(.x, na.rm = TRUE))) %>%
      pivot_longer({{ var }},
                   names_to = "var",
                   values_to = "group") %>%
      filter(!is.na(group)) %>%
      mutate(stat = " Mean") %>%
      select(everything(), value = numballs,stat_subgroup = Treatment) %>%
      ungroup()
  }

  # this function computes the differences between treatment and control
  # for the two groups created by var
  # it returns a long data frame, with 6 rows: estimate, std.error and p.value for each group
  get_meandiffs <- function(.df,var){
    #this function computes the actual means and formats the outcome
    meandiff_regress <- function(.df){
      .df %>%
        lm_robust(numballs ~ Treatment, data = .) %>%
        broom::tidy() %>%
        filter(term == "Treatment Treatment") %>%
        select(estimate,std.error,p.value)
    }

   .df <- 
      .df %>% 
      mutate( {{ var }} := as.character(as_factor( {{ var }} ))) 

    # I basically split the data frame in two and run the above 
    # function on both data sets with map.
    splitvector <- .df %>% pull( {{ var }} )
    
    .df %>%
      split(splitvector) %>%
      map(meandiff_regress) %>%
      imap(~mutate(.x, group = .y)) %>%
      reduce(bind_rows) %>% 
      pivot_longer(!group,
                   names_to = "stat_subgroup",
                   values_to = "value") %>%
      mutate(stat = "Difference in means",
             var = rlang::quo_text(enquo(var)))
  }

  # finally: this computes the difference between the two differences.
  # it ouputs a long data frame with estimate, std.error and p.value
  get_diffindiff <- function(.df,var){
    data <- 
      .df %>% 
      select(numballs,Treatment, {{ var }})

    y <- data[[1]]
    treat <- data[[2]]
    x <- data[[3]]

    lm_robust(y ~ treat *  x) %>%
        broom::tidy() %>%
        filter(term == "treat Treatment:x") %>%
        select(estimate,std.error,p.value) %>%
        pivot_longer(everything(),
                   names_to = "stat_subgroup",
                   values_to = "value")  %>%
        mutate(group = "diff in diff",
               stat = "Difference in means",
               var = rlang::quo_text(enquo(var)))
  }

  df1 <- get_means(.df,{{ var }})
  df2 <- get_meandiffs(.df,{{ var }})
  df3 <- get_diffindiff(.df,{{ var }})

  bind_rows(df1,df2,df3)
  
}

mean_diff_table(sample,victimproplost) %>%
  tabulator(rows = c("var","group"),
            columns = c("stat","stat_subgroup"),
            `Mean` =  as_paragraph(as_chunk(value,digits=2))) %>%
  as_flextable() %>%
  labelizor(j = "var", labels = col_labels, part = "all") 


# To Paper

c(quos("victimproplost"),quos(victimfamlost)) %>%
map(~mean_diff_table(sample,!!.x)) %>%
reduce(bind_rows) %>%
  tabulator(rows = c("var","group"),
            columns = c("stat","stat_subgroup"),
            `Mean` =  as_paragraph(as_chunk(value,digits=2))) %>%
  as_flextable() %>%
  mk_par(i = 1, j = c(1,2), as_paragraph(''),part = "header") %>%
  labelizor(j = "var", labels = col_labels, part = "all") %>%

  autofit()



```


## Table 6


I first define a number of helper varaibles:

- `tidy_ict()` outputs a nice and tidy data frame with coefficients, standard errors etc. from the `ict_reg()` function.
- `format_stars()` takes a coefficient and p-value and formats it to a coefficient with stars.

I also save my `sample` as a data frame (was a tibble), because `ict_reg()` didn't work on a tibble.

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

install.packages("list")

library(list)


#outputs a tidy df for ict_reg
tidy_ict <- function(reg1){
    bind_cols(reg1$coef.names, reg1$par.treat, reg1$se.treat, .name_repair = ~ c("term","estimate","std.error")) %>%
    mutate(statistic = estimate / std.error,
           df =   reg1$resid.df,
           p.value = pt(statistic, df, lower.tail = FALSE) * 2)
  }

#formats stars.
format_stars <- function(b,p,digits=3){
  stars = case_when(p < 0.01 ~ "***",
                    p < 0.05 ~ "**",
                    p < 0.1 ~ "*",
                    .default = "" )

  coeff = round(b,digits)

  paste0(coeff,stars)
}


sample_df <- 
  sample %>%
  as.data.frame() 


```

Then I need to do some convenience things:

- I put all my controls in a vector: I can insert this vector into a formula using `reformulate()`
- I have five model specification, which only differ in a number of exaplanatory variables. I make a list with the explanatory variables in each specifcation, so that I can loop over this with map.


```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}



controls <- c("agewife", "agehusband", "genderhead", "eduwife_sec", "eduhusband_prim", "tinroof", "livestockany", "terrfe_2", "terrfe_3", "treatment")



#list of model specification, in particular depvars to include with controls
specs <- list(reg1 = "husbmoreland", 
              reg2 = "victimfamlost",
              reg3 = "acledviolence10",
              reg4 = "attwifetotal",
              reg5 = c("husbmoreland", "victimfamlost", "acledviolence10", "attwifetotal"))

```

Then comes the good stuff! I loop over the list using `imap()`, where each step returns a nice data frame created by `tidy_ict()`. `imap()`
can return the name of the list element in the current iteration, which I save in the `model` variable.

Because `tabulator()` makes a mess of orders, I create a column with the order I want, and call it `order`: I prepend the varaibles that
I want at the top of the table with `01`; the intercept I prepend with `99` so it goes at the bottom. The rest get values in between. 
I also merge in the variable labels, to that I know which label to put with each item of `order`. 

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}


#run all regressions in the specifications
imap(specs, ~ictreg(reformulate(c(.x,    controls), response="numballs"), treat = "ball5", J = 4, method = "lm", data = sample_df) %>%
                  tidy_ict() %>% 
                  mutate(model = .y)) %>%
  reduce(bind_rows) %>%
  mutate(b = format_stars(estimate,p.value),
         std.error = sprintf(std.error, fmt = '%#.3f')) %>%
  select(model,term,b,std.error) %>%
  pivot_longer(b:std.error,names_to="stat",values_to="value") %>%
  mutate(order =case_when(term == "husbmoreland" ~ "01",
                          term == "victimfamlost" ~ "02",
                          term == "acledviolence10" ~ "03",
                          term == "attwifetotal" ~ "04",
                          term == "(Intercept)" ~ "99",
                          .default = "90"),
        order = paste0(order,term)) %>%
  rename(Variable = term) %>%
  left_join(read_csv(here("tables/cleandata_collabels.csv"))) %>%
  mutate(label = ifelse(Variable == "(Intercept)","Constant",label)) %>%
  write_csv(here("tables/regression_results.csv"))

# I can't find the N in ict_reg output; this finds the number of complete cases for each specification
map(specs,~sum(complete.cases(sample[,c(.x,controls,"numballs")])))

```

Finally, the below can go into the paper. I have a little helper function which adds a footer row with the Ns to a flextable.
The Ns itself I input manually here, because I can't be bothered to do it properly.

The `tabulator()` call is quite complex, but it works, and can be expanded reasonably well.

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}


add_n_to_flextable <- function(x,n,footerrow){

  for (i in 1:length(n)) {
      footercolumn <- 2 + i * 2
      x <- 
        x %>%
        mk_par(j = footercolumn,i = footerrow, as_paragraph(as_chunk(n[i],digits=0)), part = "footer") 
  }
  x %>%
    mk_par(j =1, i = 1, as_paragraph('N'), part = "footer") %>%
    #align(part="footer",align="center") %>%
    align(part="footer",align="left")
}

regs <-
  read_csv(here("tables/regression_results.csv"))


n <- c(449,402,379,449,350)

labels <-
  regs %>%
  distinct(order,label) %>%
  pull(label, name = order) 

model_labels <- paste0("(",1:5,")")
names(model_labels) <- paste0("reg",1:5)


regs %>%
  tabulator(rows = c("order","stat"),
          columns = c("model"),
          row_compose = list(stat = as_paragraph("")),
          `Beta` =  as_paragraph(as_chunk(ifelse(stat == "std.error" & !is.na(value),"(","")),
                                 as_chunk(value),
                                 as_chunk(ifelse(stat == "std.error" & !is.na(value),")","")))) %>%
  as_flextable() %>%

  #add empty footer with top and bottom row:
  add_footer_row(top = FALSE, values = rep('',12), colwidths = rep(1,12)) %>%
  theme_booktabs() %>%

  #add N's to footer, and align label left, and values center using function
  add_n_to_flextable(n,1) %>%
  labelizor(j = 1, labels = labels, part = "all") %>%
  labelizor(labels = model_labels, part = "header") %>%  

  #remove text from first two header cells
  mk_par(j = c(1,2),i = 1, as_paragraph(''), part = "header")  %>%
  
  autofit()







```